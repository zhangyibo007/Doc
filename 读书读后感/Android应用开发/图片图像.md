

### 1、CardView 使用

> CardView拥有一个卡片式的圆角边框，边框外缘有一圈阴影，边框内缘有一圈空白。
> CardView实际上是一个布局视图，继承自Framelayout，可以当作具有边框效果的特殊布局

#### 1.1、依赖

```java
implementation 'androidx.appcompat:appcompat:1.4.1' // 包含CardView
```

#### 1.2、布局XML

```xml
<androidx.cardview.widget.CardView
    android:id="@+id/cv_card"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_gravity="center_horizontal|top"
    app:cardCornerRadius="3dp"  
    app:cardElevation="3dp"
    app:contentPadding="20dp">
<!-- 
	contentPadding	内容距离CardView 的边距	
	cardElevation  阴影
	cardCornerRadius  圆角  
 -->
    <ImageView
        android:id="@+id/iv_scene"
        android:layout_width="wrap_content"
        android:layout_height="250dp"
        android:src="@drawable/ylxs" />
</androidx.cardview.widget.CardView>
```

```java
app:cardBackgroundColor //设置 CardView 背景色
app:cardPreventCornerOverlap //取消android5.0 以下版本的padding
app:cardUseCompatPadding //为 android5.0 及以上版本添加一个阴影内边距
app:cardCornerRadius //设置 CardView 圆角效果
app:contentPadding //设置 CardView 内容页边距
app:cardElevation //设置 CardView Z 轴阴影大小
```

### 2、图片装饰

​	自定View继承ImageView ，onDraw 方法中绘制定制View，覆盖在原有的ImageView上

```java
package com.example.picture.widget;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.Log;
import android.widget.ImageView;

import com.example.picture.util.MeasureUtil;
import com.example.picture.util.Utils;

@SuppressLint({"DrawAllocation", "AppCompatCustomView"})
public class DecorateImageView extends ImageView {
    private final static String TAG = "DecorateImageView";
    private Paint mPaint = new Paint(); // 声明一个画笔对象
    private int mWidth, mHeight; // 视图宽度、视图高度
    private int mTextSize = 30; // 文字大小
    private String mText; // 时间戳文本
    private Bitmap mLogo; // 标志图标
    private Bitmap mFrame; // 照片相框

    public DecorateImageView(Context context) {
        this(context, null);
    }

    public DecorateImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mPaint.setColor(0xff00ffff); // 设置画笔颜色
        mPaint.setTextSize(Utils.dip2px(context, mTextSize)); // 设置文字大小
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        mWidth = getMeasuredWidth(); // 获取视图的实际宽度
        mHeight = getMeasuredHeight(); // 获取视图的实际高度
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        if (mFrame != null) { // 装饰相框非空
            canvas.drawBitmap(mFrame, null, new Rect(0,0,mWidth,mHeight), mPaint);
        }
        if (!TextUtils.isEmpty(mText)) { // 装饰文本非空
            // 获取指定文本的高度 | MeasureUtil 测量工具 见工具类下资源
            int textHeight = (int) MeasureUtil.getTextHeight(mText, mTextSize);
            // 在画布上绘制文本
            canvas.drawText(mText, 0, mHeight - textHeight, mPaint);
        }
        if (mLogo != null) { // 装饰标志非空
            canvas.drawBitmap(mLogo, mWidth-mLogo.getWidth(), mHeight-mLogo.getHeight(), mPaint);
        }
    }

    // 不显示任何装饰
    public void showNone() {
        mText = "";
        mLogo = null;
        mFrame = null;
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 显示装饰文本
    public void showText(String text, boolean isReset) {
        if (isReset) {
            showNone(); // 不显示任何装饰
        }
        mText = text;
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 显示装饰标志
    public void showLogo(Bitmap bitmap, boolean isReset) {
        if (isReset) {
            showNone(); // 不显示任何装饰
        }
        mLogo = bitmap;
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 显示装饰相框
    public void showFrame(Bitmap bitmap, boolean isReset) {
        if (isReset) {
            showNone(); // 不显示任何装饰
        }
        mFrame = bitmap;
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 设置文字字体
    public void setTypeface(Typeface typeface) {
        mPaint.setTypeface(typeface); // 设置文字字体
    }

}
```

### 3、水波图像对象 

继承ImageView onDraw中绘制 圆形

```java
package com.example.picture.widget;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.os.Handler;
import android.os.Looper;
import android.util.AttributeSet;
import android.widget.ImageView;

import com.example.picture.util.Utils;

@SuppressLint("AppCompatCustomView")
public class RippleImageView extends ImageView {
    private Context mContext; // 声明一个上下文对象
    private Paint mPaint = new Paint(); // 声明一个画笔对象
    private int mWidth, mHeight; // 视图宽度、视图高度
    private int mRadius; // 水波的半径
    private int mIncrease; // 半径的增量
    private Handler mHandler = new Handler(Looper.myLooper()); // 声明一个处理器对象

    public RippleImageView(Context context) {
        this(context, null);
    }

    public RippleImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mContext = context;
        mIncrease = Utils.dip2px(mContext, 5);
        mPaint.setColor(0x99ffffff); // 设置画笔颜色
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        mWidth = getMeasuredWidth(); // 获取视图的实际宽度
        mHeight = getMeasuredHeight(); // 获取视图的实际高度
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        // 水波纹半径 大于0 绘制
        if (mRadius > 0) {
            canvas.drawCircle(mWidth/2, mHeight/2, mRadius, mPaint); // 画水波
        }
    }

    // 设置水波的颜色
    public void setRippleColor(int color) {
        mPaint.setColor(color); // 设置画笔颜色
    }

    // 开始播放水波动画
    public void startRipple() {
        mRadius = 0;
        mHandler.post(mRipple); // 立即启动水波刷新任务
    }

    // 定义一个水波刷新任务
    private Runnable mRipple = new Runnable() {
        @Override
        public void run() {
            mRadius += mIncrease;
            if (mRadius*mRadius > (mWidth*mWidth/4 + mHeight*mHeight/4)) { // 水波半径已超出对角线
                mRadius = 0;
                mIncrease = Utils.dip2px(mContext, 5);
            } else { // 水波半径未超出对角线
                mIncrease += Utils.dip2px(mContext, 1);
                mHandler.postDelayed(this, 50); // 延迟50毫秒后再次启动水波刷新任务
            }
            postInvalidate(); // 立即刷新视图（线程安全方式）
        }
    };

}
```

### 4、像素操作  



```java
package com.example.picture.util;

import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.graphics.Matrix;
import android.net.Uri;
import android.provider.MediaStore;
import android.util.Log;

import java.io.FileOutputStream;
import java.io.InputStream;

public class BitmapUtil {
    private final static String TAG = "BitmapUtil";

    // 把位图数据保存到指定路径的图片文件
    public static void saveImage(String path, Bitmap bitmap) {
        // 根据指定的文件路径构建文件输出流对象
        try (FileOutputStream fos = new FileOutputStream(path)) {
            // 把位图数据压缩到文件输出流中
            bitmap.compress(Bitmap.CompressFormat.JPEG, 80, fos);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // 图片黑白效果
    public static Bitmap convertBlack(Bitmap origin) {
        int width = origin.getWidth(); // 获取位图的宽
        int height = origin.getHeight(); // 获取位图的高
        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);
        int[] pixels = new int[width * height]; // 通过位图的大小创建像素点数组
        origin.getPixels(pixels, 0, width, 0, 0, width, height);
        int alpha = 0xFF << 24;
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                int grey = pixels[width * i + j];
                int red = ((grey & 0x00FF0000) >> 16);
                int green = ((grey & 0x0000FF00) >> 8);
                int blue = (grey & 0x000000FF);
                grey = (int) (red * 0.3 + green * 0.59 + blue * 0.11);
                grey = alpha | (grey << 16) | (grey << 8) | grey;
                pixels[width * i + j] = grey;
            }
        }
        bitmap.setPixels(pixels, 0, width, 0, 0, width, height);
        return bitmap;
    }

    // 图片怀旧效果
    public static Bitmap convertOld(Bitmap origin) {
        int width = origin.getWidth();
        int height = origin.getHeight();
        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);
        int pixColor = 0;
        int pixR = 0, pixG = 0, pixB = 0, newR = 0, newG = 0, newB = 0;
        int[] pixels = new int[width * height];
        origin.getPixels(pixels, 0, width, 0, 0, width, height);
        for (int i = 0; i < height; i++) {
            for (int k = 0; k < width; k++) {
                pixColor = pixels[width * i + k];
                pixR = Color.red(pixColor);
                pixG = Color.green(pixColor);
                pixB = Color.blue(pixColor);
                newR = (int) (0.393 * pixR + 0.769 * pixG + 0.189 * pixB);
                newG = (int) (0.349 * pixR + 0.686 * pixG + 0.168 * pixB);
                newB = (int) (0.272 * pixR + 0.534 * pixG + 0.131 * pixB);
                int newColor = Color.argb(255, newR > 255 ? 255 : newR,
                        newG > 255 ? 255 : newG, newB > 255 ? 255 : newB);
                pixels[width * i + k] = newColor;
            }
        }
        bitmap.setPixels(pixels, 0, width, 0, 0, width, height);
        return bitmap;
    }

    // 图片底片效果
    public static Bitmap convertNegative(Bitmap origin) {
        int width = origin.getWidth();
        int height = origin.getHeight();
        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);
        int[] oldPixels = new int[width * height];
        int[] newPixels = new int[width * height];
        int color, pixelsR, pixelsG, pixelsB, pixelsA;
        origin.getPixels(oldPixels, 0, width, 0, 0, width, height);
        for (int i = 1; i < height * width; i++) {
            color = oldPixels[i];
            // 获取RGB分量
            pixelsA = Color.alpha(color);
            pixelsR = Color.red(color);
            pixelsG = Color.green(color);
            pixelsB = Color.blue(color);
            // 转换
            pixelsR = (255 - pixelsR);
            pixelsG = (255 - pixelsG);
            pixelsB = (255 - pixelsB);
            // 均小于等于255大于等于0
            if (pixelsR > 255) {
                pixelsR = 255;
            } else if (pixelsR < 0) {
                pixelsR = 0;
            }
            if (pixelsG > 255) {
                pixelsG = 255;
            } else if (pixelsG < 0) {
                pixelsG = 0;
            }
            if (pixelsB > 255) {
                pixelsB = 255;
            } else if (pixelsB < 0) {
                pixelsB = 0;
            }
            // 根据新的RGB生成新像素
            newPixels[i] = Color.argb(pixelsA, pixelsR, pixelsG, pixelsB);
        }
        bitmap.setPixels(newPixels, 0, width, 0, 0, width, height);
        return bitmap;
    }

    // 图片模糊效果
    public static Bitmap convertBlur(Bitmap origin) {
        int width = origin.getWidth();
        int height = origin.getHeight();
        int hRadius = width>150 ? width/150 : 1; // 水平方向模糊度
        int vRadius = height>150 ? height/150 : 1; // 垂直方向模糊度
        int iterations = 7; // 模糊迭代度
        int[] inPixels = new int[width * height];
        int[] outPixels = new int[width * height];
        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        origin.getPixels(inPixels, 0, width, 0, 0, width, height);
        for (int i = 0; i < iterations; i++) {
            blur(inPixels, outPixels, width, height, hRadius);
            blur(outPixels, inPixels, height, width, vRadius);
        }
        blurFractional(inPixels, outPixels, width, height, hRadius);
        blurFractional(outPixels, inPixels, height, width, vRadius);
        bitmap.setPixels(inPixels, 0, width, 0, 0, width, height);
        return bitmap;
    }

    private static void blur(int[] in, int[] out, int width, int height, int radius) {
        int widthMinus1 = width - 1;
        int tableSize = 2 * radius + 1;
        int[] divide = new int[256 * tableSize];
        for (int i = 0; i < 256 * tableSize; i++) {
            divide[i] = i / tableSize;
        }
        int inIndex = 0;
        for (int y = 0; y < height; y++) {
            int outIndex = y;
            int ta = 0, tr = 0, tg = 0, tb = 0;
            for (int i = -radius; i <= radius; i++) {
                int rgb = in[inIndex + clamp(i, 0, width - 1)];
                ta += (rgb >> 24) & 0x99; // 调整灰度。0x99表示半透明
                tr += (rgb >> 16) & 0xff; // 调整红色
                tg += (rgb >> 8) & 0xff; // 调整绿色
                tb += rgb & 0xff; // 调整蓝色
            }

            for (int x = 0; x < width; x++) {
                out[outIndex] = (divide[ta] << 24) | (divide[tr] << 16) | (divide[tg] << 8) | divide[tb];
                int i1 = x + radius + 1;
                if (i1 > widthMinus1) {
                    i1 = widthMinus1;
                }
                int i2 = x - radius;
                if (i2 < 0) {
                    i2 = 0;
                }
                int rgb1 = in[inIndex + i1];
                int rgb2 = in[inIndex + i2];
                ta += ((rgb1 >> 24) & 0xff) - ((rgb2 >> 24) & 0xff);
                tr += ((rgb1 & 0xff0000) - (rgb2 & 0xff0000)) >> 16;
                tg += ((rgb1 & 0xff00) - (rgb2 & 0xff00)) >> 8;
                tb += (rgb1 & 0xff) - (rgb2 & 0xff);
                outIndex += height;
            }
            inIndex += width;
        }
    }

    public static void blurFractional(int[] in, int[] out, int width, int height, float radius) {
        radius -= (int) radius;
        float f = 1.0f / (1 + 2 * radius);
        int inIndex = 0;
        for (int y = 0; y < height; y++) {
            int outIndex = y;
            out[outIndex] = in[0];
            outIndex += height;
            for (int x = 1; x < width - 1; x++) {
                int i = inIndex + x;
                int rgb1 = in[i - 1];
                int rgb2 = in[i];
                int rgb3 = in[i + 1];
                int a1 = (rgb1 >> 24) & 0xff;
                int r1 = (rgb1 >> 16) & 0xff;
                int g1 = (rgb1 >> 8) & 0xff;
                int b1 = rgb1 & 0xff;
                int a2 = (rgb2 >> 24) & 0xff;
                int r2 = (rgb2 >> 16) & 0xff;
                int g2 = (rgb2 >> 8) & 0xff;
                int b2 = rgb2 & 0xff;
                int a3 = (rgb3 >> 24) & 0xff;
                int r3 = (rgb3 >> 16) & 0xff;
                int g3 = (rgb3 >> 8) & 0xff;
                int b3 = rgb3 & 0xff;
                a1 = a2 + (int) ((a1 + a3) * radius);
                r1 = r2 + (int) ((r1 + r3) * radius);
                g1 = g2 + (int) ((g1 + g3) * radius);
                b1 = b2 + (int) ((b1 + b3) * radius);
                a1 *= f;
                r1 *= f;
                g1 *= f;
                b1 *= f;
                out[outIndex] = (a1 << 24) | (r1 << 16) | (g1 << 8) | b1;
                outIndex += height;
            }
            out[outIndex] = in[width - 1];
            inIndex += width;
        }
    }

    private static int clamp(int x, int a, int b) {
        return (x < a) ? a : Math.min(x, b);
    }

    // 水平翻转图像，也就是把镜中像左右翻过来
    public static Bitmap getFlipBitmap(Bitmap bitmap) {
        Matrix matrix = new Matrix(); // 创建操作图片用的矩阵对象
        matrix.postScale(-1, 1); // 执行图片的旋转动作
        // 创建并返回旋转后的位图对象
        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),
                bitmap.getHeight(), matrix, false);
    }

    // 获得旋转角度之后的位图对象
    public static Bitmap getRotateBitmap(Bitmap bitmap, float rotateDegree) {
        Matrix matrix = new Matrix(); // 创建操作图片用的矩阵对象
        matrix.postRotate(rotateDegree); // 执行图片的旋转动作
        // 创建并返回旋转后的位图对象
        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),
                bitmap.getHeight(), matrix, false);
    }

    // 获得比例缩放之后的位图对象
    public static Bitmap getScaleBitmap(Bitmap bitmap, double scaleRatio) {
        Matrix matrix = new Matrix(); // 创建操作图片用的矩阵对象
        matrix.postScale((float)scaleRatio, (float)scaleRatio);
        // 创建并返回缩放后的位图对象
        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),
                bitmap.getHeight(), matrix, false);
    }

    // 获得自动缩小后的位图对象
    public static Bitmap getAutoZoomImage(Context ctx, Uri uri) {
        Log.d(TAG, "getAutoZoomImage uri="+uri.toString());
        Bitmap zoomBitmap = null;
        // 打开指定uri获得输入流对象
        try (InputStream is = ctx.getContentResolver().openInputStream(uri)) {
            // 从输入流解码得到原始的位图对象
            Bitmap originBitmap = BitmapFactory.decodeStream(is);
            int ratio = originBitmap.getWidth()/2000+1;
            // 获得比例缩放之后的位图对象
            zoomBitmap = getScaleBitmap(originBitmap, 1.0f/ratio);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return zoomBitmap;
    }

    // 通知相册来了张新图片
    public static void notifyPhotoAlbum(Context ctx, String filePath) {
        try {
            String fileName = filePath.substring(filePath.lastIndexOf("/")+1);
            MediaStore.Images.Media.insertImage(ctx.getContentResolver(),
                    filePath, fileName, null);
            Uri uri = Uri.parse("file://" + filePath);
            Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri);
            ctx.sendBroadcast(intent);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```

### 5、图像裁剪

自定义View 继承View 

1、先绘制 阴影部门

2、绘制裁剪后的图片

xml文件

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="40dp">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:paddingLeft="5dp"
            android:gravity="center"
            android:text="请选择裁剪区域"
            android:textColor="@color/black"
            android:textSize="17sp" />
        <!-- 裁剪选择-->
        <Spinner
            android:id="@+id/sp_zone"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:gravity="center"
            android:spinnerMode="dialog" />
    </LinearLayout>

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="200dp" >

        <ImageView
            android:id="@+id/iv_old"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />
        <!-- 自定义View -->
        <com.example.picture.widget.CropImageView
            android:id="@+id/civ_over"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:background="@color/transparent"
            android:scaleType="fitXY"
            android:visibility="gone" />
    </FrameLayout>

    <Button
        android:id="@+id/btn_save_image"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="保存图片"
        android:textColor="@color/black"
        android:textSize="17sp" />

    <ImageView
        android:id="@+id/iv_new"
        android:layout_width="match_parent"
        android:layout_height="200dp"
        android:scaleType="centerInside" />
</LinearLayout>
```

自定义View  CropImageView

```java
package com.example.picture.widget;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.View;

import com.example.picture.util.BitmapUtil;

@SuppressLint("ClickableViewAccessibility")
public class CropImageView extends View {
    private Paint mPaintShade; // 声明一个阴影画笔对象
    private Bitmap mOrigBitmap = null; // 声明一个原始的位图对象
    private Bitmap mCropBitmap = null; // 声明一个裁剪后的位图对象
    private Rect mRect = new Rect(0, 0, 0, 0); // 矩形边界

    public CropImageView(Context context) {
        this(context, null);
    }

    public CropImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        // 创建一个画笔
        mPaintShade = new Paint();
        // 设置画笔的颜色
        mPaintShade.setColor(0x99000000);
    }

    // 设置原始的位图对象
    public void setOrigBitmap(Bitmap orig) {
        mOrigBitmap = orig;
    }

    // 获得裁剪后的位图对象
    public Bitmap getCropBitmap() {
        return mCropBitmap;
    }

    // 设置位图的矩形边界
    public boolean setBitmapRect(Rect rect) {
        if (mOrigBitmap == null) { // 原始位图为空
            return false;
        } else if (rect.left < 0 || rect.left > mOrigBitmap.getWidth()) { // 左侧边界非法
            return false;
        } else if (rect.top < 0 || rect.top > mOrigBitmap.getHeight()) { // 上方边界非法
            return false;
        } else if (rect.right <= 0 || rect.left + rect.right > mOrigBitmap.getWidth()) { // 右侧边界非法
            return false;
        } else if (rect.bottom <= 0 || rect.top + rect.bottom > mOrigBitmap.getHeight()) { // 下方边界非法
            return false;
        }
        mRect = rect;
        // 根据指定的四周边界，裁剪相应尺寸的位图对象
        mCropBitmap = Bitmap.createBitmap(mOrigBitmap,
                mRect.left, mRect.top, mRect.right, mRect.bottom);
        postInvalidate(); // 立即刷新视图（线程安全方式）
        return true;
    }

    // 获取位图的矩形边界
    public Rect getBitmapRect() {
        return mRect;
    }

    // 左右翻转图像
    public void flip() {
        // 水平翻转图像，也就是把镜中像左右翻过来
        mCropBitmap = BitmapUtil.getFlipBitmap(mCropBitmap);
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 在下级视图都绘制完成后触发
    @Override
    protected void dispatchDraw(Canvas canvas) {
        if (mOrigBitmap == null) {
            return;
        }
        // 画外圈阴影
        Rect rectShade = new Rect(0, 0, getMeasuredWidth(), getMeasuredHeight());
        canvas.drawRect(rectShade, mPaintShade);
        // 画高亮处的图像
        canvas.drawBitmap(mCropBitmap, mRect.left, mRect.top, new Paint());
    }

}
```

Activity 使用 

```java
package com.example.picture;

import android.graphics.Bitmap;
import android.graphics.Rect;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.Spinner;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;

import com.example.picture.util.BitmapUtil;
import com.example.picture.util.DateUtil;
import com.example.picture.widget.CropImageView;

public class BitmapCutActivity extends AppCompatActivity {
    private CropImageView civ_over; // 声明一个裁剪视图对象
    private ImageView iv_old; // 声明一个原始图片的图像视图对象
    private ImageView iv_new; // 声明一个最新图片的图像视图对象

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_bitmap_cut);
        civ_over = findViewById(R.id.civ_over);
        // 旧图
        iv_old = findViewById(R.id.iv_old);
        // 新图
        iv_new = findViewById(R.id.iv_new);
        // 保存按钮
        findViewById(R.id.btn_save_image).setOnClickListener(v -> {
            // 阴影区域
            civ_over.setVisibility(View.GONE);
            // 获取裁剪视图处理后的位图
            Bitmap bitmap = civ_over.getCropBitmap();
            // 设置图像视图的位图对象
            iv_new.setImageBitmap(bitmap);

            // 生成图片文件的保存路径
            String path = String.format("%s/%s.jpg",
                    getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString(),
                    DateUtil.getNowDateTime());
            // 把位图保存为图片文件
            BitmapUtil.saveImage(path, bitmap);
            // 通知相册来了张新图片
            BitmapUtil.notifyPhotoAlbum(this, path);

            Toast.makeText(this, "成功保存图片文件：" + path, Toast.LENGTH_SHORT).show();
            // 初始化裁剪区域下拉框
            initZoneSpinner();
        });
        // 开启位图视图的绘图缓存
        iv_old.setDrawingCacheEnabled(true);
        // 设置图像视图的资源编号
        iv_old.setImageResource(R.drawable.butterfly);
        new Handler(Looper.myLooper()).postDelayed(() -> initZoneSpinner(), 200);
    }

    // 初始化裁剪区域下拉框
    private void initZoneSpinner() {
        ArrayAdapter<String> zoneAdapter = new ArrayAdapter<>(this,
                R.layout.item_select, zoneNameArray);
        Spinner sp_zone = findViewById(R.id.sp_zone);
        sp_zone.setPrompt("请选择裁剪区域");
        sp_zone.setAdapter(zoneAdapter);
        sp_zone.setOnItemSelectedListener(new ZoneSelectedListener());
        sp_zone.setSelection(0);
    }

    private String[] zoneNameArray = {"不裁剪", "中间", "左上角", "右上角", "左下角", "右下角"};
    class ZoneSelectedListener implements AdapterView.OnItemSelectedListener {
        public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
            // 设置裁剪区域是否显示
            civ_over.setVisibility(arg2==0?View.GONE:View.VISIBLE);
            // 获取旧的位图// 从绘图缓存获取位图对象
            Bitmap bitmap = iv_old.getDrawingCache();
            // 获取宽高
            int width = bitmap.getWidth(), height = bitmap.getHeight();
            // 设置裁剪视图的原始位图
            civ_over.setOrigBitmap(bitmap);
            // 以下依据裁剪区域分别设置裁剪视图的位图边界
            if (arg2 == 1) { // 中间
                civ_over.setBitmapRect(new Rect(width/4, height/4, width/2, height/2));
            } else if (arg2 == 2) { // 左上角
                civ_over.setBitmapRect(new Rect(0, 0, width/2, height/2));
            } else if (arg2 == 3) { // 右上角
                civ_over.setBitmapRect(new Rect(width/2, 0, width/2, height/2));
            } else if (arg2 == 4) { // 左下角
                civ_over.setBitmapRect(new Rect(0, height/2, width/2, height/2));
            } else if (arg2 == 5) { // 右下角
                civ_over.setBitmapRect(new Rect(width/2, height/2, width/2, height/2));
            }
        }

        public void onNothingSelected(AdapterView<?> arg0) {}
    }

}
```

### 6、位图缩放、旋转操作

自定义View，重写ondraw 方法，绘制bitmap图像，通过 | Matrix 矩阵对图像操作

xml

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:paddingLeft="5dp"
        android:orientation="horizontal" >

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="缩放比率"
            android:textColor="@color/black"
            android:textSize="17sp" />

        <Spinner
            android:id="@+id/sp_scale"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:spinnerMode="dialog" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="旋转角度"
            android:textColor="@color/black"
            android:textSize="17sp" />

        <Spinner
            android:id="@+id/sp_rotate"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:spinnerMode="dialog" />

    </LinearLayout>

    <CheckBox
        android:id="@+id/ck_flip"
        android:layout_width="match_parent"
        android:layout_height="40dp"
        android:text="是否左右翻转图像"
        android:textColor="@color/black"
        android:textSize="17sp" />

    <com.example.picture.widget.BitmapView
        android:id="@+id/bv_image"
        android:layout_width="match_parent"
        android:layout_height="200dp"
        android:background="@color/white" />

    <Button
        android:id="@+id/btn_save_image"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="保存图片"
        android:textColor="@color/black"
        android:textSize="17sp" />

</LinearLayout>
```



自定义View 

```java
package com.example.picture.widget;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.util.AttributeSet;
import android.view.View;

import com.example.picture.util.BitmapUtil;

@SuppressLint("DrawAllocation")
public class BitmapView extends View {
    private static final String TAG = "BitmapView";
    private float mScaleRatio = 1.0f; // 缩放比例
    private float mRotateDegree = 0; // 旋转角度
    private Bitmap mBitmap; // 声明一个位图对象
    private int mBitmapWidth; // 位图宽度
    private int mBitmapHeight; // 位图高度
    private int mOffsetX = 0, mOffsetY = 0; // 横轴和纵轴上的偏移

    public BitmapView(Context context) {
        this(context, null);
    }

    public BitmapView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    // 设置位图对象
    public void setImageBitmap(Bitmap bitmap) {
        mBitmap = bitmap;
        mBitmapWidth = mBitmap.getWidth();
        mBitmapHeight = mBitmap.getHeight();
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 左右翻转图像
    public void flip() {
        // 水平翻转图像，也就是把镜中像左右翻过来
        mBitmap = BitmapUtil.getFlipBitmap(mBitmap);
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 设置缩放比例。isReset为true表示按照原始尺寸进行缩放，为false表示按照当前尺寸进行缩放
    public void setScaleRatio(float ratio, boolean isReset) {
        if (isReset) {
            mScaleRatio = ratio;
        } else {
            mScaleRatio *= ratio;
        }
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 设置旋转角度。isReset为true表示按照原始方向进行旋转，为false表示按照当前方向进行缩放
    public void setRotateDegree(int degree, boolean isReset) {
        if (isReset) {
            mRotateDegree = degree;
        } else {
            mRotateDegree += degree;
        }
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 设置偏移距离。isReset为true表示按照原始位置进行移动，为false表示按照当前位置进行移动
    public void setOffset(int offsetX, int offsetY, boolean isReset) {
        if (isReset) {
            mOffsetX = offsetX;
            mOffsetY = offsetY;
        } else {
            mOffsetX += offsetX;
            mOffsetY += offsetY;
        }
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (mBitmap == null) {
            return;
        }
        // 获取视图的实际宽度
        int width = getMeasuredWidth();
        // 获取视图的实际高度
        int height = getMeasuredHeight();

        int new_width = (int) (mBitmapWidth * mScaleRatio);
        int new_height = (int) (mBitmapHeight * mScaleRatio);
        Bitmap bitmap = mBitmap;
        if (mScaleRatio != 1) {
            // 生成缩放后的位图对象 | Matrix 缩放
            bitmap = BitmapUtil.getScaleBitmap(mBitmap, mScaleRatio);
        }

        if (mRotateDegree != 0) {
            // 生成旋转后的位图对象 | Matrix 旋转
            bitmap = BitmapUtil.getRotateBitmap(bitmap, mRotateDegree);
        }
        // 在画布上的指定位置绘制位图对象
        canvas.drawBitmap(bitmap, (width - new_width) / 2 + mOffsetX,
                (height - new_height) / 2 + mOffsetY, new Paint());
    }

}
```



Activity使用

```java
package com.example.picture;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;
import android.os.Environment;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.Spinner;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;

import com.example.picture.util.BitmapUtil;
import com.example.picture.util.DateUtil;
import com.example.picture.widget.BitmapView;

public class BitmapChangeActivity extends AppCompatActivity {
    private BitmapView bv_image; // 声明一个位图视图对象

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_bitmap_change);
        // 是否左右翻转
        CheckBox ck_flip = findViewById(R.id.ck_flip);
        bv_image = findViewById(R.id.bv_image);

        ck_flip.setOnCheckedChangeListener((buttonView, isChecked) -> {
            bv_image.flip(); // 左右翻转图像
        });

        findViewById(R.id.btn_save_image).setOnClickListener(v -> {
            Bitmap bitmap = bv_image.getDrawingCache(); // 从绘图缓存获取位图对象
            // 生成图片文件的保存路径
            String path = String.format("%s/%s.jpg",
                    getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString(),
                    DateUtil.getNowDateTime());
            BitmapUtil.saveImage(path, bitmap); // 把位图保存为图片文件
            BitmapUtil.notifyPhotoAlbum(this, path); // 通知相册来了张新图片
            Toast.makeText(this, "成功保存图片文件：" + path, Toast.LENGTH_LONG).show();
        });
        initScaleSpinner(); // 初始化缩放比率下拉框
        initRotateSpinner(); // 初始化旋转角度下拉框
    }

    @Override
    protected void onStart() {
        super.onStart();
        // 开启位图视图的绘图缓存
        bv_image.setDrawingCacheEnabled(true);
        // 加载图片资源
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.butterfly);
        //设置资源
        bv_image.setImageBitmap(bitmap); // 设置位图视图的位图对象

    }

    @Override
    protected void onStop() {
        super.onStop();
        // 关闭位图视图的绘图缓存
        bv_image.setDrawingCacheEnabled(false);
    }

    // 初始化缩放比率下拉框
    private void initScaleSpinner() {
        ArrayAdapter<String> scaleAdapter = new ArrayAdapter<>(this,
                R.layout.item_select, scaleArray);
        Spinner sp_scale = findViewById(R.id.sp_scale);
        sp_scale.setPrompt("请选择缩放比率");
        sp_scale.setAdapter(scaleAdapter);
        sp_scale.setOnItemSelectedListener(new ScaleSelectedListener());
        sp_scale.setSelection(3);
    }

    private String[] scaleArray = {"0.25", "0.5", "0.75", "1.0", "1.5", "2.0", "4.0"};
    class ScaleSelectedListener implements OnItemSelectedListener {
        public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
            // 设置缩放比例
            bv_image.setScaleRatio(Float.parseFloat(scaleArray[arg2]), true);
        }

        public void onNothingSelected(AdapterView<?> arg0) {}
    }

    // 初始化旋转角度下拉框
    private void initRotateSpinner() {
        ArrayAdapter<String> rotateAdapter = new ArrayAdapter<>(this,
                R.layout.item_select, rotateArray);
        Spinner sp_rotate = findViewById(R.id.sp_rotate);
        sp_rotate.setPrompt("请选择旋转角度");
        sp_rotate.setAdapter(rotateAdapter);
        sp_rotate.setOnItemSelectedListener(new RotateSelectedListener());
        sp_rotate.setSelection(0);
    }

    private String[] rotateArray = {"0", "45", "90", "135", "180", "225", "270", "315"};
    class RotateSelectedListener implements OnItemSelectedListener {
        public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
            // 设置旋转角度
            bv_image.setRotateDegree(Integer.parseInt(rotateArray[arg2]), true);
        }

        public void onNothingSelected(AdapterView<?> arg0) {}
    }

}
```

### 7、bitmap 转Drawable

```java
Drawable drawable = new BitmapDrawable(getResources(), mOriginBitmap);
drawable.setAlpha((int) (255*ratio)); // 设置图形的灰度值
```



### 8、bitmap裁剪

通过自定义 BitmapDrawable 重写 onDraw方法

#### 8.1 自定义圆形

```java
public class CircleDrawable extends BitmapDrawable {
    private Paint mPaint = new Paint(); // 声明一个画笔对象

    public CircleDrawable(Context ctx, Bitmap bitmap) {
        super(ctx.getResources(), bitmap);
        // 创建一个位图着色器，CLAMP表示边缘拉伸
        BitmapShader shader = new BitmapShader(bitmap, TileMode.CLAMP, TileMode.CLAMP);
        mPaint.setShader(shader); // 设置画笔的着色器对象
    }

    @Override
    public void draw(Canvas canvas) {
        int width = getBitmap().getWidth();
        int height = getBitmap().getHeight();
        int radius = Math.min(width, height) / 2 - 4;
        // 在画布上绘制圆形，也就是只显示圆形内部的图像
        canvas.drawCircle(width/2, height/2, radius, mPaint);
    }

}
```

#### 8.2 椭圆裁剪

```java
public class OvalDrawable extends BitmapDrawable {
    private Paint mPaint = new Paint(); // 声明一个画笔对象

    public OvalDrawable(Context ctx, Bitmap bitmap) {
        super(ctx.getResources(), bitmap);
        // 创建一个位图着色器，CLAMP表示边缘拉伸
        BitmapShader shader = new BitmapShader(bitmap, TileMode.CLAMP, TileMode.CLAMP);
        mPaint.setShader(shader); // 设置画笔的着色器对象
    }

    @Override
    public void draw(Canvas canvas) {
        // 在画布上绘制椭圆，也就是只显示椭圆内部的图像
        canvas.drawOval(0, 0, getBitmap().getWidth(), getBitmap().getHeight(), mPaint);
    }

}
```

#### 8.3 圆角矩形剪裁

```java
public class RoundDrawable extends BitmapDrawable {
    private Paint mPaint = new Paint(); // 声明一个画笔对象
    private int mRoundRadius; // 圆角的半径

    public RoundDrawable(Context ctx, Bitmap bitmap) {
        super(ctx.getResources(), bitmap);
        // 创建一个位图着色器，CLAMP表示边缘拉伸
        BitmapShader shader = new BitmapShader(bitmap, TileMode.CLAMP, TileMode.CLAMP);
        mPaint.setShader(shader); // 设置画笔的着色器对象
        mRoundRadius = Utils.dip2px(ctx, 30);
    }

    @Override
    public void draw(Canvas canvas) {
        RectF rect = new RectF(0, 0, getBitmap().getWidth(), getBitmap().getHeight());
        // 在画布上绘制圆角矩形，也就是只显示圆角矩形内部的图像
        canvas.drawRoundRect(rect, mRoundRadius, mRoundRadius, mPaint);
    }

}
```

#### 8.4  添加文字

```java
package com.example.picture.widget;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Typeface;
import android.graphics.drawable.BitmapDrawable;

import com.example.picture.util.MeasureUtil;
import com.example.picture.util.Utils;

public class MarkTextDrawable extends BitmapDrawable {
    private Context mContext; // 声明一个上下文对象
    private Paint mPaint = new Paint(); // 声明一个画笔对象
    private String mText; // 水印文字
    private int mTextSize = 40; // 文字大小

    public MarkTextDrawable(Context ctx, Bitmap bitmap) {
        super(ctx.getResources(), bitmap);
        mContext = ctx;
    }

    // 设置水印文字及其字体
    public void setMarkerText(String text, Typeface typeface) {
        mText = text;
        if (typeface != null) {
            mPaint.setColor(0xffffffff); // 设置画笔颜色
            mPaint.setTextSize(Utils.dip2px(mContext, mTextSize)); // 设置文字大小
            mPaint.setTypeface(typeface); // 设置文字字体
        }
    }

    @Override
    public void draw(Canvas canvas) {
        super.draw(canvas);
        if (mText == null) {
            return;
        }
        int bitmapWidth = getBitmap().getWidth();
        int bitmapHeight = getBitmap().getHeight();
        // 获取指定文本的宽度（其实就是长度）
        int textWidth = (int) MeasureUtil.getTextWidth(mText, mTextSize);
        // 获取指定文本的高度
        int textHeight = (int) MeasureUtil.getTextHeight(mText, mTextSize);
        // 在画布上绘制文本
        canvas.drawText(mText, bitmapWidth/2 - textWidth, bitmapHeight - textHeight, mPaint);
    }

}
```

加载文字，并且使用

```java
package com.example.picture;

import androidx.appcompat.app.AppCompatActivity;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Typeface;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.Spinner;

import com.example.picture.widget.MarkTextDrawable;

public class DrawableTextActivity extends AppCompatActivity {
    private final static String TAG = "DrawableTextActivity";
    private Bitmap mOriginBitmap; // 原始位图
    private ImageView iv_picture; // 声明一个图像视图对象
    private Typeface[] mTypeFaceArray; // 字体数组

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_drawable_text);
        iv_picture = findViewById(R.id.iv_picture);
        mOriginBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.mandarin_duck);
        iv_picture.setImageBitmap(mOriginBitmap); // 设置图像视图的位图对象
        new Handler(Looper.myLooper()).post(() -> loadTypeFace()); // 加载字体文件
    }

    // 加载字体文件
    private void loadTypeFace() {
        mTypeFaceArray = new Typeface[fontFileArray.length];
        for (int i=0; i<fontFileArray.length; i++) {
            String fontFile = "fonts/" + fontFileArray[i] + ".ttf";
            // 根据assets目录下的字体文件创建字体对象
            mTypeFaceArray[i] = Typeface.createFromAsset(getAssets(), fontFile);
        }
        initFontSpinner(); // 初始化中文字体下拉框
    }

    // 初始化中文字体下拉框
    private void initFontSpinner() {
        ArrayAdapter<String> fontAdapter = new ArrayAdapter<>(this,
                R.layout.item_select, fontNameArray);
        Spinner sp_font = findViewById(R.id.sp_font);
        sp_font.setPrompt("请选择中文字体");
        sp_font.setAdapter(fontAdapter);
        sp_font.setOnItemSelectedListener(new FontSelectedListener());
        sp_font.setSelection(0);
    }

    private String[] fontNameArray = {"常规", "仿宋", "楷体", "隶书", "黑体", "幼圆",
            "华文行楷", "华文新魏", "华文彩云", "华文琥珀", "方正舒体", "方正姚体"};
    private String[] fontFileArray = {"Regular", "FangSong", "KaiTi", "LiShu", "HeiTi", "YouYuan",
            "HangKai", "XinWei", "CaiYun", "HuPo", "ShuTi", "YaoTi"};
    class FontSelectedListener implements AdapterView.OnItemSelectedListener {
        public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
            // 根据指定位图创建水印图形对象
            MarkTextDrawable drawable = new MarkTextDrawable(DrawableTextActivity.this, mOriginBitmap);
            drawable.setMarkerText("鸳鸯戏水", mTypeFaceArray[arg2]); // 设置水印文字及其字体
            iv_picture.setImageDrawable(drawable); // 设置图像视图的图形对象
        }

        public void onNothingSelected(AdapterView<?> arg0) {}
    }

}
```

#### 8.5 添加图片水印

```java
package com.example.picture.widget;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.drawable.BitmapDrawable;

import com.example.picture.util.BitmapUtil;

public class MarkIconDrawable extends BitmapDrawable {
    private Paint mPaint = new Paint(); // 声明一个画笔对象
    private Bitmap mMarker; // 水印图标
    private int mDirection; // 水印方位

    public MarkIconDrawable(Context ctx, Bitmap bitmap) {
        super(ctx.getResources(), bitmap);
        mPaint.setColor(0x99ffffff); // 设置画笔颜色
    }

    // 设置水印图标及其方位
    public void setMarkerIcon(Bitmap bitmap, int direction) {
        int originHeight = getBitmap().getHeight();
        int markerHeight = bitmap.getHeight();
        double ratio = 1.0*originHeight/markerHeight/3;
        // 创建缩放后的水印图标
        mMarker = BitmapUtil.getScaleBitmap(bitmap, ratio);
        mDirection = direction;
    }

    @Override
    public void draw(Canvas canvas) {
        super.draw(canvas);
        if (mMarker == null) {
            return;
        }
        int widthGap = getBitmap().getWidth() - mMarker.getWidth();
        int heightGap = getBitmap().getHeight() - mMarker.getHeight();
        if (mDirection == 0) { // 在中间
            canvas.drawBitmap(mMarker, widthGap/2, heightGap/2, mPaint);
        } else if (mDirection == 1) { // 左上角
            canvas.drawBitmap(mMarker, 0, 0, mPaint);
        } else if (mDirection == 2) { // 右上角
            canvas.drawBitmap(mMarker, widthGap, 0, mPaint);
        } else if (mDirection == 3) { // 左下角
            canvas.drawBitmap(mMarker, 0, heightGap, mPaint);
        } else if (mDirection == 4) { // 右下角
            canvas.drawBitmap(mMarker, widthGap, heightGap, mPaint);
        }
    }

}
```

使用

```java
package com.example.picture;

import androidx.appcompat.app.AppCompatActivity;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.Spinner;

import com.example.picture.widget.MarkIconDrawable;

public class DrawableIconActivity extends AppCompatActivity {
    private final static String TAG = "DrawableIconActivity";
    private Bitmap mOriginBitmap; // 原始位图
    private Bitmap mMarkerBitmap; // 水印位图
    private ImageView iv_picture; // 声明一个图像视图对象

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_drawable_icon);
        iv_picture = findViewById(R.id.iv_picture);
        mOriginBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.mandarin_duck);
        mMarkerBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.flower_lotus);
        iv_picture.setImageBitmap(mOriginBitmap); // 设置图像视图的位图对象
        initDirectionSpinner(); // 初始化图标方位下拉框
    }

    // 初始化图标方位下拉框
    private void initDirectionSpinner() {
        ArrayAdapter<String> directionAdapter = new ArrayAdapter<>(this,
                R.layout.item_select, directionArray);
        Spinner sp_direction = findViewById(R.id.sp_direction);
        sp_direction.setPrompt("请选择图标方位");
        sp_direction.setAdapter(directionAdapter);
        sp_direction.setOnItemSelectedListener(new DirectionSelectedListener());
        sp_direction.setSelection(0);
    }

    private String[] directionArray = {"中间水印", "左上水印", "右上水印", "左下水印", "右下水印"};
    class DirectionSelectedListener implements AdapterView.OnItemSelectedListener {
        public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
            // 根据指定位图创建水印图形对象
            MarkIconDrawable drawable = new MarkIconDrawable(DrawableIconActivity.this, mOriginBitmap);
            drawable.setMarkerIcon(mMarkerBitmap, arg2); // 设置水印图标及其方位
            iv_picture.setImageDrawable(drawable); // 设置图像视图的图形对象
        }

        public void onNothingSelected(AdapterView<?> arg0) {}
    }

}
```

xml

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="40dp">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:paddingLeft="5dp"
            android:gravity="center"
            android:text="请选择图标方位"
            android:textColor="@color/black"
            android:textSize="17sp" />

        <Spinner
            android:id="@+id/sp_direction"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:gravity="center"
            android:spinnerMode="dialog" />
    </LinearLayout>

    <ImageView
        android:id="@+id/iv_picture"
        android:layout_width="match_parent"
        android:layout_height="200dp"
        android:scaleType="centerInside" />
</LinearLayout>
```

### 9、项目实战

#### 9.1 生成大头贴 页面

> ​	1、添加文字水印+字体设置
>
> ​	2、图片装饰
>
> ​	3、相框装饰
>
> ​	4、图像采集

##### 9.1.1  自定义view 集成 Image 

主要用来绘制 自定义文字、相框、图片水印

```java
package com.example.picture.widget;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.Log;
import android.widget.ImageView;

import com.example.picture.util.MeasureUtil;
import com.example.picture.util.Utils;

@SuppressLint({"DrawAllocation", "AppCompatCustomView"})
public class DecorateImageView extends ImageView {
    private final static String TAG = "DecorateImageView";
    private Paint mPaint = new Paint(); // 声明一个画笔对象
    private int mWidth, mHeight; // 视图宽度、视图高度
    private int mTextSize = 30; // 文字大小
    private String mText; // 时间戳文本
    private Bitmap mLogo; // 标志图标
    private Bitmap mFrame; // 照片相框

    public DecorateImageView(Context context) {
        this(context, null);
    }

    public DecorateImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mPaint.setColor(0xff00ffff); // 设置画笔颜色
        mPaint.setTextSize(Utils.dip2px(context, mTextSize)); // 设置文字大小
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        mWidth = getMeasuredWidth(); // 获取视图的实际宽度
        mHeight = getMeasuredHeight(); // 获取视图的实际高度
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        if (mFrame != null) { // 装饰相框非空
            canvas.drawBitmap(mFrame, null, new Rect(0,0,mWidth,mHeight), mPaint);
        }
        if (!TextUtils.isEmpty(mText)) { // 装饰文本非空
            // 获取指定文本的高度
            int textHeight = (int) MeasureUtil.getTextHeight(mText, mTextSize);
            // 在画布上绘制文本
            canvas.drawText(mText, 0, mHeight - textHeight, mPaint);
        }
        if (mLogo != null) { // 装饰标志非空
            canvas.drawBitmap(mLogo, mWidth-mLogo.getWidth(), mHeight-mLogo.getHeight(), mPaint);
        }
    }

    // 不显示任何装饰
    public void showNone() {
        mText = "";
        mLogo = null;
        mFrame = null;
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 显示装饰文本
    public void showText(String text, boolean isReset) {
        if (isReset) {
            showNone(); // 不显示任何装饰
        }
        mText = text;
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 显示装饰标志
    public void showLogo(Bitmap bitmap, boolean isReset) {
        if (isReset) {
            showNone(); // 不显示任何装饰
        }
        mLogo = bitmap;
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 显示装饰相框
    public void showFrame(Bitmap bitmap, boolean isReset) {
        if (isReset) {
            showNone(); // 不显示任何装饰
        }
        mFrame = bitmap;
        postInvalidate(); // 立即刷新视图（线程安全方式）
    }

    // 设置文字字体
    public void setTypeface(Typeface typeface) {
        mPaint.setTypeface(typeface); // 设置文字字体
    }

}
```

##### 9.1.2 xml页面布局

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <include layout="@layout/title_purikura" />

    <com.example.picture.widget.DecorateImageView
        android:id="@+id/div_photo"
        android:layout_width="match_parent"
        android:layout_height="270dp"
        android:src="@drawable/no_photo" />

    <Button
        android:id="@+id/btn_collect"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="采集头像"
        android:textColor="@color/black"
        android:textSize="17sp" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:orientation="vertical">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="50dp"
            android:orientation="horizontal">

            <EditText
                android:id="@+id/et_text"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:layout_margin="5dp"
                android:background="@drawable/editext_selector"
                android:hint="请填写标记文字"
                android:textColor="@color/black"
                android:textSize="15sp" />

            <Button
                android:id="@+id/btn_text"
                android:layout_width="70dp"
                android:layout_height="match_parent"
                android:text="添加"
                android:textColor="@color/black"
                android:textSize="15sp" />
        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:gravity="center"
                android:paddingLeft="5dp"
                android:text="标志图片样式："
                android:textColor="@color/black"
                android:textSize="17sp" />

            <Spinner
                android:id="@+id/sp_logo"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:spinnerMode="dialog" />
        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:gravity="center"
                android:paddingLeft="5dp"
                android:text="照片相框种类："
                android:textColor="@color/black"
                android:textSize="17sp" />

            <Spinner
                android:id="@+id/sp_frame"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:spinnerMode="dialog" />
        </LinearLayout>

    </LinearLayout>

</LinearLayout>
```

##### 9.1.3 Activity页面

```java
package com.example.picture;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

import com.example.picture.util.BitmapUtil;
import com.example.picture.util.DateUtil;
import com.example.picture.widget.DecorateImageView;

public class PurikuraActivity extends AppCompatActivity {
    private final static String TAG = "PurikuraActivity";
    // 采集头像的请求码
    private int COLLECT_CODE = 14;
    // 声明一个装饰视图对象
    private DecorateImageView div_photo;
    // 声明一个编辑框对象
    private EditText et_text;
    // 是否已采集头像
    private boolean haveCollected = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_purikura);
        //返回关闭页面
        findViewById(R.id.iv_back).setOnClickListener(v -> finish());
        // 标题栏
        TextView tv_title = findViewById(R.id.tv_title);
        tv_title.setText("大头贴");
        //保存生成好的图片
        TextView tv_option = findViewById(R.id.tv_option);
        tv_option.setText("保存");
        tv_option.setOnClickListener(v -> savePurikura());

        div_photo = findViewById(R.id.div_photo);
        // 标记文字
        et_text = findViewById(R.id.et_text);
        // 左下角文字装饰
        findViewById(R.id.btn_text).setOnClickListener(v -> {
            String text = et_text.getText().toString();
            div_photo.showText(text, false); // 显示装饰文本
        });
        // 采集图片
        findViewById(R.id.btn_collect).setOnClickListener(v -> {
            // 下面跳到头像采集页面
            Intent intent = new Intent(this, PortraitActivity.class);
            startActivityForResult(intent, COLLECT_CODE);
        });
        // 初始化标志图片下拉框
        initLogoSpinner();
        // 初始化相框种类下拉框
        initFrameSpinner();
        // 加载字体文件
        new Handler(Looper.myLooper()).post(() -> loadTypeFace());
    }

    // 保存加工好的大头贴图片
    private void savePurikura() {
        if (!haveCollected) {
            Toast.makeText(this, "请先采集头像图片", Toast.LENGTH_SHORT).show();
            return;
        }
        // 开启装饰视图的绘图缓存
        div_photo.setDrawingCacheEnabled(true);
        // 从绘图缓存获取位图对象
        Bitmap bitmap = div_photo.getDrawingCache();
        // 生成图片文件的保存路径
        String path = String.format("%s/%s.jpg",
                getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString(),
                DateUtil.getNowDateTime());
        BitmapUtil.saveImage(path, bitmap); // 把位图保存为图片文件
        BitmapUtil.notifyPhotoAlbum(this, path); // 通知相册来了张新图片
        Toast.makeText(this, "已保存大头贴图片 "+path, Toast.LENGTH_SHORT).show();
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
        super.onActivityResult(requestCode, resultCode, intent);
        if (resultCode == RESULT_OK && requestCode == COLLECT_CODE) { // 从采集头像返回
            String pic_path = intent.getStringExtra("pic_path");
            // 设置图像视图的路径对象
            div_photo.setImageURI(Uri.parse(pic_path));
            haveCollected = true;
        }
    }

    // 初始化标志图片下拉框
    private void initLogoSpinner() {
        ArrayAdapter<String> logoAdapter = new ArrayAdapter<>(this,
                R.layout.item_select, logoNameArray);
        Spinner sp_logo = findViewById(R.id.sp_logo);
        sp_logo.setPrompt("请选择标志图片");
        sp_logo.setAdapter(logoAdapter);
        sp_logo.setOnItemSelectedListener(new LogoSelectedListener());
        sp_logo.setSelection(0);
    }

    private String[] logoNameArray = {"无标志", "春之兰花", "夏之荷花", "秋之菊花", "冬之梅花"};
    class LogoSelectedListener implements AdapterView.OnItemSelectedListener {
        public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
            Bitmap bitmap = null;
            if (arg2 == 1) { // 春之兰花
                bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.flower_orchid);
            } else if (arg2 == 2) { // 夏之荷花
                bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.flower_lotus);
            } else if (arg2 == 3) { // 秋之菊花
                bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.flower_chrysanthemum);
            } else if (arg2 == 4) { // 冬之梅花
                bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.flower_plum);
            }
            div_photo.showLogo(bitmap, false); // 显示装饰标志
        }

        public void onNothingSelected(AdapterView<?> arg0) {}
    }

    // 初始化相框种类下拉框
    private void initFrameSpinner() {
        ArrayAdapter<String> frameAdapter = new ArrayAdapter<>(this,
                R.layout.item_select, frameNameArray);
        Spinner sp_frame = findViewById(R.id.sp_frame);
        sp_frame.setPrompt("请选择相框种类");
        sp_frame.setAdapter(frameAdapter);
        sp_frame.setOnItemSelectedListener(new FrameSelectedListener());
        sp_frame.setSelection(0);
    }

    private String[] frameNameArray = {"无相框", "长方相框", "椭圆相框", "稻草相框", "爱心相框"};
    class FrameSelectedListener implements AdapterView.OnItemSelectedListener {
        public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
            Bitmap bitmap = null;
            if (arg2 == 1) { // 长方相框
                bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.photo_frame1);
            } else if (arg2 == 2) { // 椭圆相框
                bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.photo_frame2);
            } else if (arg2 == 3) { // 稻草相框
                bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.photo_frame3);
            } else if (arg2 == 4) { // 爱心相框
                bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.photo_frame4);
            }
            div_photo.showFrame(bitmap, false); // 显示装饰相框
        }

        public void onNothingSelected(AdapterView<?> arg0) {}
    }

    // 加载字体文件
    private void loadTypeFace() {
        // 根据assets目录下的字体文件创建字体对象
        Typeface kaiti = Typeface.createFromAsset(getAssets(), "fonts/KaiTi.ttf");
        div_photo.setTypeface(kaiti); // 设置文字字体
    }
}
```

#### 9.2、 图片采集页面

​	1、相机拍照返回数据

​	2、相册选择返回数据

​	3、图片的放大缩小、左移、右移动

​	4、图像左右翻转

​	5、自定义图像裁剪

##### 9.2.1 xml定义

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <include layout="@layout/title_purikura" />

    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="270dp" >

        <com.example.picture.widget.BitmapView

            android:id="@+id/bv_photo"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:background="@color/blue_light"
            android:scaleType="centerCrop" />

        <com.example.picture.widget.CropImageView
            android:id="@+id/civ_photo"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />
    </RelativeLayout>

    <Button
        android:id="@+id/btn_combine"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="拍照或从相册选取"
        android:textColor="@color/black"
        android:textSize="17sp" />

    <LinearLayout
        android:id="@+id/ll_adjust"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:orientation="vertical"
        android:visibility="visible">

        <CheckBox
            android:id="@+id/ck_flip"
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:text="是否左右翻转图像"
            android:textColor="@color/black"
            android:textSize="17sp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="30dp"
            android:layout_margin="10dp"
            android:gravity="center"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="缩小"
                android:textColor="@color/black"
                android:textSize="17sp" />

            <SeekBar
                android:id="@+id/sb_scale"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:max="100"
                android:progress="30" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="放大"
                android:textColor="@color/black"
                android:textSize="17sp" />

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="30dp"
            android:layout_margin="10dp"
            android:gravity="center"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="左移"
                android:textColor="@color/black"
                android:textSize="17sp" />

            <SeekBar
                android:id="@+id/sb_horizontal"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:max="100"
                android:progress="50" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="右移"
                android:textColor="@color/black"
                android:textSize="17sp" />

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="30dp"
            android:layout_margin="10dp"
            android:gravity="center"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="上移"
                android:textColor="@color/black"
                android:textSize="17sp" />

            <SeekBar
                android:id="@+id/sb_vertical"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:max="100"
                android:progress="50" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="下移"
                android:textColor="@color/black"
                android:textSize="17sp" />

        </LinearLayout>
    </LinearLayout>

</LinearLayout>
```

##### 9.2.2  activity使用 

```java
package com.example.picture;

import androidx.appcompat.app.AppCompatActivity;

import android.app.Activity;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.Rect;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.provider.MediaStore;
import android.util.Log;
import android.view.View;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.SeekBar;
import android.widget.TextView;
import android.widget.Toast;

import com.example.picture.util.BitmapUtil;
import com.example.picture.util.DateUtil;
import com.example.picture.widget.BitmapView;
import com.example.picture.widget.CropImageView;

public class PortraitActivity extends AppCompatActivity implements SeekBar.OnSeekBarChangeListener {
    private final static String TAG = "PortraitActivity";
    private int COMBINE_CODE = 4; // 既可拍照获得现场图片、也可在相册挑选已有图片的请求码
    private BitmapView bv_photo; // 声明一个位图视图对象
    private CropImageView civ_photo; // 声明一个裁剪视图对象
    private LinearLayout ll_adjust; // 声明一个线性布局对象
    private SeekBar sb_scale; // 声明一个拖动条对象
    private SeekBar sb_horizontal; // 声明一个拖动条对象
    private SeekBar sb_vertical; // 声明一个拖动条对象

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_portrait);
        // 标题
        TextView tv_title = findViewById(R.id.tv_title);
        tv_title.setText("采集头像");
        // 返回形象制作
        TextView tv_option = findViewById(R.id.tv_option);
        tv_option.setText("确定");
        tv_option.setOnClickListener(v -> finishCollect());
        // 采集回来的图片
        bv_photo = findViewById(R.id.bv_photo);
        //裁剪 阴影框
        civ_photo = findViewById(R.id.civ_photo);
        // 图片操作页面
        ll_adjust = findViewById(R.id.ll_adjust);
        // 相册选择|拍照
        findViewById(R.id.btn_combine).setOnClickListener(v -> openSelectDialog());
        // 图片是左右 否旋转
        CheckBox ck_flip = findViewById(R.id.ck_flip);
        ck_flip.setOnCheckedChangeListener((buttonView, isChecked) -> {
            bv_photo.flip(); // 左右翻转图像
            civ_photo.flip(); // 左右翻转图像
        });
        // 缩放
        sb_scale = findViewById(R.id.sb_scale);
        // 左移
        sb_horizontal = findViewById(R.id.sb_horizontal);
        // 右移
        sb_vertical = findViewById(R.id.sb_vertical);

        sb_scale.setOnSeekBarChangeListener(this);
        sb_horizontal.setOnSeekBarChangeListener(this);
        sb_vertical.setOnSeekBarChangeListener(this);
    }

    // 结束头像采集
    private void finishCollect() {
        if (civ_photo.getCropBitmap() == null) {
            Toast.makeText(this, "请先选好头像图片", Toast.LENGTH_SHORT).show();
            return;
        }
        // 生成图片文件的保存路径
        String path = String.format("%s/%s.jpg",
                getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString(),
                DateUtil.getNowDateTime());

        BitmapUtil.saveImage(path, civ_photo.getCropBitmap()); // 把位图保存为图片文件
        BitmapUtil.notifyPhotoAlbum(this, path); // 通知相册来了张新图片
        Intent intent = new Intent(); // 创建一个新意图
        intent.putExtra("pic_path", path);
        setResult(Activity.RESULT_OK, intent); // 携带意图返回前一个页面
        finish(); // 关闭当前页面
    }

    // 打开选择对话框（要拍照还是去相册）
    private void openSelectDialog() {
        // 声明相机的拍照行为
        Intent photoIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
        Intent[] intentArray = new Intent[] { photoIntent };
        // 声明相册的打开行为
        Intent albumIntent = new Intent(Intent.ACTION_GET_CONTENT);
        albumIntent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, false); // 是否允许多选
        albumIntent.setType("image/*"); // 类型为图像
        // 容纳相机和相册在内的选择意图
        Intent chooserIntent = new Intent(Intent.ACTION_CHOOSER);
        chooserIntent.putExtra(Intent.EXTRA_TITLE, "请拍照或选择图片");
        chooserIntent.putExtra(Intent.EXTRA_INITIAL_INTENTS, intentArray);
        chooserIntent.putExtra(Intent.EXTRA_INTENT, albumIntent);
        // 创建封装好标题的选择器意图
        Intent chooser = Intent.createChooser(chooserIntent, "选择图片");
        // 在页面底部弹出多种选择方式的列表对话框
        startActivityForResult(chooser, COMBINE_CODE);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
        super.onActivityResult(requestCode, resultCode, intent);
        if (resultCode == RESULT_OK && requestCode == COMBINE_CODE) { // 从组合选择返回
            if (intent.getData() != null) { // 从相册选择一张照片
                Uri uri = intent.getData(); // 获得已选择照片的路径对象
                // 根据指定图片的uri，获得自动缩小后的位图对象
                Bitmap bitmap = BitmapUtil.getAutoZoomImage(this, uri);
                showPicture(bitmap); // 显示已选择的图片
            } else if (intent.getExtras() != null) { // 拍照的缩略图
                Object obj = intent.getExtras().get("data");
                if (obj instanceof Bitmap) { // 属于位图类型
                    Bitmap bitmap = (Bitmap) obj; // 强制转成位图对象
                    showPicture(bitmap); // 显示已选择的图片
                }
            }
        }
    }

    // 显示已选择的图片
    private void showPicture(Bitmap origin) {
        bv_photo.setDrawingCacheEnabled(true); // 开启位图视图的绘图缓存
        bv_photo.setImageBitmap(origin); // 设置图像视图的位图对象
        ll_adjust.setVisibility(View.VISIBLE);
        sb_scale.setProgress(30); // 设置拖动条的当前进度
        sb_horizontal.setProgress(50); // 设置拖动条的当前进度
        sb_vertical.setProgress(50); // 设置拖动条的当前进度
        Bitmap bitmap = bv_photo.getDrawingCache(); // 从绘图缓存获取位图对象
        if (bitmap == null) {
            return;
        }
        int width = bitmap.getWidth(), height = bitmap.getHeight();
        civ_photo.setOrigBitmap(bitmap); // 设置裁剪视图的原始位图
        // 设置位图的矩形边界
        civ_photo.setBitmapRect(new Rect(width/8, height/8, width/4*3, height/4*3));
        bv_photo.setDrawingCacheEnabled(false); // 关闭位图视图的绘图缓存
    }

    // 刷新图像展示
    private void refreshImage() {
        Bitmap bitmap = bv_photo.getDrawingCache(); // 从绘图缓存获取位图对象
        civ_photo.setOrigBitmap(bitmap); // 设置裁剪视图的原始位图
        civ_photo.setBitmapRect(civ_photo.getBitmapRect()); // 设置裁剪视图的位图边界
    }

    @Override
    public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
        // 开启位图视图的绘图缓存
        bv_photo.setDrawingCacheEnabled(true);
        // 放大缩小
        if (seekBar.getId() == R.id.sb_scale) {
            // 设置位图视图的缩放比率
            bv_photo.setScaleRatio(progress/33f, true);
        }
        // 平移
        else if (seekBar.getId()==R.id.sb_horizontal || seekBar.getId()==R.id.sb_vertical) {
            int viewWidth = bv_photo.getMeasuredWidth(); // 获取视图的实际宽度
            int viewHeight = bv_photo.getMeasuredHeight(); // 获取视图的实际高度
            int offsetX = (int) ((sb_horizontal.getProgress()-50)/50f*viewWidth);
            int offsetY = (int) ((sb_vertical.getProgress()-50)/50f*viewHeight);
            Log.d(TAG, "viewWidth="+viewWidth+", offsetX="+offsetX+", viewHeight="+viewHeight+", offsetY="+offsetY);
            bv_photo.setOffset(offsetX, offsetY, true); // 设置位图视图的偏移距离
        }
        refreshImage(); // 刷新图像展示
        bv_photo.setDrawingCacheEnabled(false); // 关闭位图视图的绘图缓存
    }

    @Override
    public void onStartTrackingTouch(SeekBar seekBar) {}

    @Override
    public void onStopTrackingTouch(SeekBar seekBar) {}
}
```

### 10、总结

1、图像装饰 2种方式

​	自定义View继承ImageVIew onDraw中绘制

​	使用 继承 BitmapDrawable 方式 

2、裁剪 

​	使用 BitmapDrawable  方式

​	bitmap的create方法

3、图片缩放，旋转 

​	通过 Matrix 操作

